How Does Duplication Arise?
	1. Imposed duplication - Developers feel they have ne choice - the environment seems to require duplication

	2. Inadvertant duplication - Developers don't realize that they are duplicating information

	3. Impatient duplication - Developers get lazy and duplicate because it seems easier.

	4. Interdeveloper duplication - Multiple people on a team (or on different teams) duplicate a piece of information.


Eliminate Effects Between Unrelated Things.

* Orthogonality means components are independent

* Change one part doesn't require changes in another.

Orthogonality = "no overlap"
If two ideas, skills, or systems are orthogonal, they work separetely without stepping on each other.

So when someone says:
	Keep your system orthogonal
	They mean: "Design it so the parts are independent. Don't mix concerns."

You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.

Grain Productivity
	1. Changes are localized, so development time and testing time are reduced. It's easier to write relatively small, self-contained components than a single large block of code. Simple components can be designed, coded, unit tested, and then forgotten - there is no need to keep changing existsing code as you add new code.

	2. An orthogonal approach also promotes reuse. If components have specific, well-defined responsibilities, they can be combined with new components in ways that were not envisioned by their original implementors. The more loosely coupled your systems the easier they are to reconfigure and reengineer.


Reduce Risk.
An orthogonal approach reduces the risks inherent in any development.
	
	1. Diseased sections of code are isolated. If a module is sick, it's less likely to spread the symptoms around the rest of the system. It's also easier to slice it out and transplant in something new and healthy.

	2. The resulting system is less fragile. Make small changes and fixes to a particular area, and any problems you generate will be restricted to that area.

	3. An orthogonal system will probably be better tested, because it will be easier to design and run tests on its components.

	4. You wil not be as tightly tied to a particular vendor, product or platform, because the interfaces to these third-party components will be isolated to smaller parts of the overall development. 

Coding
	There are several techniques you can use to maintain orthogonality

		1. Keep your code decoupled: Write shy code - modules that don't reveal anything unnecessary to other modules and that don't rely on other modules' implementations. Try the Law of Demeter which we discuss in Decoupling and the Law of Demeter. If you need to change an object's state, get the object to do it for you. This way your code remains isolated from the other code's implementation and increases the chances that you'll remain orthogonal.

		2. Avoid global data: Every time your code references global data, it ties itself into the other components that share that data. Even globals that you intend only to read can lead to trouble(for example, if you suddenly need to change your code to be multithreaded). In general, your code is easier to understand and maintain if you explicity pass any required context into your modules. In object-oriented applications, context is often passed as parameters to objects' constructors.

		3. Avoid similar functions: Often you'll come across a set of functions that all look similar - maybe they share common code at the start and end, but each has a different central algorithm. Duplicate code is a symptom of structural problems. have a look at STRATEGY PATTERN in Design Patterns for a better implementation. 



Tracer Bullets


The tracer code approach has many advantages:

	1. Users get to see something working early. - If you have successfully communicated what you are doing, your users will know they are seeing something immature. They won't be disappointed by a lack of functionality; they'll be estatic to see some visible progress toward their system. They also get to contribute as the project progresses, increasing their buy-in. These same users will likely be the people who'll tell you how close to target each iteration is.

	2. Developers build a structure to work in.  - The most daunting piece of paper is the one with nothing written on it. If you have worked out all the end-to-end interactions of your application, and have embodied them in code, then your team won't need to pull as much out of thin air. This makes everyone more productive, and encourages consistency.

	3. You have an integration platform - As the system is connected end-to-end, you have an environment to which you can add new pieces of code once they have been unit-tested. Rahter than attempting a big-bang integration, you'll be integrating every day(often many times a day). The impact of each new change is more apparent, and the interactions are more limited, so debugginh and testing are faster and more accurate.

	4. You have something to demonstrate. Project sponsors and top brass have a tendency to want to see demos at the most inconvenient times. With tracer code, you'll always have something to show them.

| Feature          | Tracer Code                                   | Prototype                           |
| ---------------- | --------------------------------------------- | ----------------------------------- |
| **Code Quality** | Production-quality, clean                     | Quick & dirty                       |
| **Purpose**      | Build structure for real system               | Explore idea / validate approach    |
| **Lifespan**     | Stays and grows into final product            | Often discarded                     |
| **Architecture** | Uses the **real architecture & tech**         | May skip architecture               |
| **Example**      | First working ‚Äúlogin + DB + API‚Äù in a new app | Mocked-up UI for testing with users |



Things to Prototype
What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn't been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren't comfortable with. You can prototype.

	1. Architecture.
	2. New functionality in an existing system.
	3. Structure or contents of external data.
	4. Third-party tools or components.
	5. Performance issues.
	6. User interface design

NOTE: PROTOTYPE TO LEARN

How to Use Prototypes
When building a prototype, what details can you ignore?

	Correctness: You may be able to use dummy data where appropriate

	Completeness: The prototype may function only in a very limited sense, perhaps with only one preselected piece of input data and one menu item.

	Robustness: Error checking is likely to be incomplete or missing entirely. If you stray from predefined path, the prototype may crash and burn in a glorious display of pyrotechnics. That's okay.

How Not to Use Prototypes

	Before you embark on any code-base prototyping, make sure that everyone understands that you are writing disposable code. Prototypes can be deceptively attractive to people who don't know that they are just prototypes. You must make it very clear that this code disposable, incomplete, and unable to be completed.


================================================================

Estimating

	Core Idea
		* Estimating is not about 100% accurate.
		* It's about being close enough to guide decisions.
		* With practice, you'll develop an engineer's intuition for size, time, cost, and performance.

	That's why they say:
		Estimate to avoid surprises. 

üîé Ballpark Estimation ‚Äî Meaning

A ballpark estimate is a rough, approximate guess about cost, time, or effort.
	‚Ä¢	It‚Äôs not exact.
	‚Ä¢	It‚Äôs good enough to see the scale of the work.
	‚Ä¢	The idea comes from baseball ‚Üí if the ball lands somewhere in the ballpark, it‚Äôs close enough to count.

üëâ In software:
A ballpark estimate tells stakeholders if something is going to take days, weeks, or months ‚Äî not the exact number of hours.


Where Do Estimates Come From?

	All estimates are based on models of the problem. But before we get too deeply into the techniques of building models, we have to mention a basic estimating trick that always gives good answers: ask someone who's already done it. Before you get too committed to model building, cast around for someone who's been in a similar situation in the past.

--

Estimating Project Schedules.
	This needn't be a paradox if you practice incremental development, repeating the following steps.
		1. Check requirements
		2. Analyze risk
		3. Design, implement, integrate.
		4. Validate with the users.


Tip 19: Iterate the Schedule with the Code.
	‚ÄúIterate the schedule with the code‚Äù = make your timeline a living, accurate thing driven by real engineering signals and automation. It turns scheduling from guesswork into an ongoing, measurable process that adapts as your codebase (and uncovered realities) evolve.


What to Say When Asked for an Estimate.

You say, "I'll get back to you."

Example

üëé At the coffee machine:
Manager: ‚ÄúHow long do you think adding that report feature will take?‚Äù
Developer: ‚ÄúEh, maybe 2 days?‚Äù
‚Üí A week later: Manager says ‚ÄúYou said 2 days, why isn‚Äôt it done yet?‚Äù

üëç Better:
Developer: ‚ÄúI can‚Äôt really say without looking at the code. I‚Äôll check and get back with a proper estimate.‚Äù
‚Üí Now the expectation is managed.



===============================================================================================================================



The Basic Tools.

    Tip 20: Keep knowledge in Plain Text.

    Examples
        ‚úÖ Good (Plain Text)

        Source code (.java, .py, .c)

        Configuration files (.properties, .yml, .json, .ini)

        Documentation (.md, .txt, .rst)

        SQL scripts (.sql)

        Infrastructure as code (.tf, .yaml for Kubernetes)

        ‚ùå Bad (Opaque/Binary)

        Word docs (.docx) for specs (hard to diff/merge)

        Excel sheets (.xls) for configuration (not transparent, easy to break)

        Proprietary binary formats for data dumps (can‚Äôt grep/diff)

        Closed tools where knowledge lives only in a GUI (no text to store in Git)


The Power of Test
    Since larger and slower aren't the most frequently requested features from users, why bother with plain text? Whar are the benefits?

    1. Insurance against absolescence.
    2. Leverage.
    3. Easier testing.


Shell Games
	* If you do all work using GUIs, you are missing out on the full capabilities of your environment. You won't be able to automate common tasks, or use the full power of the tools avaulable to you. And you won't be able to combine your tools to create customized macro tools. A benefit of GUIs is WYSIWYG - what you see is what you get. The disadvantages is WYSIAYG - what you see is all you get.

TIP 21
	Use the Power of Command Shells.



Debugging Strategies
	NOTE:
		Bug Reproduction
			No, our bugs aren't really multiplying (although some of them are probably old enough to do it legally). We're talking about a different kind of reproduction.
			The best way to start fixing a bug is to make it reproducible. After all, if you can't reproduce it, how will you know if it is ever fixed?
			But we want more than a bug that can be reproduced by following some long series of steps; we want a bug that can be reproduced with a single command. It's a lot harder to fuix a bug if you have to go through 15 steps to get to the point where the bug shows up.

=========================================================================================================================================================

PRAGMATIC PARANOIA.
 Tip 30 - You can't write PERFECT SOFTWARE.

If there's any doubt, we validate all information we're given. We use assertions to detect bad data. We check for consistency, put constraints on database columns, and generally feel pretty good about ourselves. 
	BUT PRAGMATIC PROGRAMMERS TAKE THIS A STEP FURTHER. THEY DON'T TRUST THEMSELVES, EITHER. Knowing that no one writes PERFECT CODE, including themselves, Pragmatic Programmers code in defenses against their own mistakes. We describe the first defensive measure in Design by Contract: clients and suppliers must agree on rights and responsibilities.

1.	Notes - Dead Programs Tell No Lies.
		* Principle: Fail fast - stop program when error occur instead of continuing in an invalid state.
		* Reason: A crash is visible and contained; silent bugs cause data corruption, security risks, hidden failures.
		* Practices: 
			* Validate inputs & invariants.
			* Throw exception on unexpected conditions. 
			* Log errors clearly before termination
			* Use rollback/recovery mechanisms (e.g DB transactions)

		* Mindset: Better no result than a wrong result.

2. Assertive Programming - describes an easy method of checking along the way - write code that actively verifies your assumptions.
	Assertive Programming = don't just assume your code is correct - make your codde check its own assumpltions as it runs.
	For example: 
		* If you assume a list is never empty -> assert it
	This way, if reality doesn't match your assumptions, the program fails immediately instead of quietly producing wrong result.


	Notes for your Notebook
		* Assertive Programming = check assumptions explicity with assertions.
		* Purpose: catch bugs early, fail fast, self-documented expectations.
		* Use for: preconditions, postconditions, invariants
		* Don't assume -> assert!

----------------------------------------------------------------------------------------------------------------------

When everybody actually is out to get you, paranoia is just good thinking
														-> Woody Allen

What does it mean? 
If danger is real, caution isn't paranoia - it's smart thinking.
	We have learned:
		1. Don't trust your code, your assumptions, or even your own inputs.
		2. If bugs, bad data, and user mistakes will happen, then being "paranoid" - adding checks, assertions, and defensive code - isn't crazy. IT'S JUST GOOD ENGINEERING.

===============================================================================================================================================================

																					DESIGN BY CONTRACT
													Nothing astonishes men so much as common sense and plain dealing. - Ralph Waldo Emerson

One of the best solutions for ensuring plain dealing is the CONTRACT - A Contract defines your rights and responsibilities, as well as those of the other party. 

DbC is commong sense formalized:
	* DbC is common sense formalized:
		* Caller promises preconditions (e.g amount > 0).
		* Method promises postconditions (e.g balance increases).
		* System enforces invariants (e.g total debits == total credits).
	* This "plain dealing" is just being explicit about what's expected and what's guaranteed.
	* Instead of "trust me, it works," DbC is like a contract you can't ignore.

Example:
	Without contract
```
public void withdraw(Account account, double amount) {
    // assumes account is valid, amount positive, and enough balance...
    account.setBalance(account.getBalance() - amount);
}
```

With Design by Contract 

```
public void withdraw(Account account, double amount) {
    assert account != null : "Account must not be null";
    assert amount > 0 : "Amount must be positive";
    assert account.getBalance() >= amount : "Insufficient funds";

    double oldBalance = account.getBalance();
    account.setBalance(oldBalance - amount);

    assert account.getBalance() == oldBalance - amount : "Postcondition failed";
}
```

================================================================================================

			Loop Invariants

A loop invariant is a logical statement that is always true:
	* Before the loop starts.
	* During every iteration of the loop.
	* When the loop ends.

It's like a mini contract for your loop - describing what must always hold ture, even while the loop is in progress.

Example: Finding the Maximum in an Array.

```
int m = arr[0];      // assume arr.length > 0
int i = 1;

// Loop invariant: m = max(arr[0 : i-1])
while (i < arr.length) {
    m = Math.max(m, arr[i]);
    i = i + 1;
}
```

1. Before loop starts:
	* m = arr[0];
	* i = 1
	* INVARIANT says: "m" is the max of all elements from arr[0] up to i.
	* So m = max(arr[0:0]) => TRUE

------------------------------------------------------------------------------------------------

												SEMANTIC INVARIANTS
1. They Are fundamental truths about a system - rules that must never be broken unders any circumstances.
2. They act like PHILOSOPHICAL CONTRACTS: higher-level guarantees that guide design decisions.
3. They differ from business policies (which can change), because semantic invariants are permanent and central to the meaning of the system.

Example: Debit Card Transaction System.
	1. Requirement: A user must never be charged twice for the same transaction.
	2. Why? Because duplicate charges would break trust and create financial harm.
	3. So, the system is designed with this invariant in mind

Difference Between Policy and Semantic Invariant
1. Policy: Rules that can change(ATM withdrawals are limited to 500 dollar in a day - management can update this.
2. Semantic Invariant: Rules that must always hold.


Tip 35: Finish What You Start.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
																	BEND, OR BREAK
In Reversibility, we talked about the perils of irreversible decisions. In this chapter, we'll tell you how to make reversible decisions. In this chapter, we'll tell tou how to make reversible decisions, so your code can stay flexible and adaptable in the face of an uncertain world.

First we need to look at coupling - the dependencies among modules of code. In decoupling and the Law of Demeter we'll show how to keep separate concepts separate, and decrease coupling.

A key concept in creating flexible code is the separation of a data model from a view, or presentation, of that model. We'll decouple models fron views in It's Just A View.

Finally, there‚Äôs a technique for decoupling modules even further by providing a meeting place where modules can exchange data anonymously and asynchronously. This is the topic of Blackboards.
Armed with these techniques, you can write code that will ‚Äúroll with the punches.‚Äù


```
The Law of Demeter, also known as the principle of least knowledge, is a software design guideline that states an object should only communicate with its immediate "friends" and not with "strangers". This means an object should only call methods on itself, objects passed in as arguments, any objects it creates, or its direct component objects. The core idea is to reduce coupling between classes, making code easier to test, refactor, and maintain. 
```

--------------------------------------------------------------------------------------------------------------------------------------------

																			Decoupling and the Law of Demeter.
Good fences make good neighbors.

In Orthogonality, page 34, and Design By Contract, page 109, we suggested that writting "shy" code is beneficial. But "shy" works two ways: 
	1. Don't reveal yourself to others
	2. Don't interact with too many people.

-----

The Law Of Demeter for Functions

The Law of Demeter for functions attempts to minimize coupling between modules in any given program. It tries to prevent you from reaching into an object to gain access to a third objecct's methods.
By writing "shy" code that honors the Law Of Demeter as much as possible, we can achieve our objective:
	
	Tip 36: Minimize Coupling Between Modules

====================================================================================================================
																Metadata-Driven Applications
Put Abstractions in Code, Details in Metadata.

There are several benefits to this approach:
	1. It forces you to decouple your design, which results in a more flexible and adaptable program.
	2. It forces you to create a more robust, abstract design be deferring details - deferring them all the way out of the program.
	3. You can customize the application without recompiling it. You can also use this level of customization to provide easy work-arounds for critical bugs in live production systems.
	4. You may even be able to implement several differen projects using the same application engine, but with different metadata.


DON'T WRITE DODO-CODE
Without metadata, your code is not as adaptable or flexible as it could be. Is this a bad thing? Well, out here in the real world, species that don't adapt die. 

The dodo didn't adapt to the presence of humans and their livestock on the island of Mauritius, and quickly became extinct. It was the first documented extinction of a species at the hand of man.
DON'T LET YOUR PROJECT (OR YOUR CAREER) GO THE WAY OF THE DODO.



============================================================================================================================================

---

### üß© 1. **What people *think* coding is**

The book says:

> ‚ÄúConventional wisdom says that once a project is in the coding phase, the work is mostly mechanical‚Ä¶‚Äù

That means many people (especially managers or beginners) **believe coding is just typing** ‚Äî taking a design document and translating it into code like a robot.
They think once design is done, programmers just follow instructions.

üí¨ Example of that mindset:

> ‚ÄúWe already designed it. Just go code it up!‚Äù
> (as if the programmer‚Äôs job is mechanical work, not thinking work)

---

### ‚ö†Ô∏è 2. **But in reality ‚Äî coding requires constant thinking**

The authors argue:

> ‚ÄúCoding is not mechanical.‚Äù

Every line of code involves **choices**:

* Which data structure is best?
* Is this logic clean and readable?
* What happens if the input is invalid?
* Is this algorithm efficient?
* What if I need to change this later?

So, a good programmer is always **analyzing, questioning, and improving** ‚Äî not just typing.

---

### üí• 3. **‚ÄúProgramming by coincidence‚Äù**

They warn:

> ‚ÄúDevelopers who don‚Äôt actively think about their code are programming by coincidence.‚Äù

That means:

* You write code that ‚Äújust happens‚Äù to work ‚Äî but you don‚Äôt really understand *why*.
* If it breaks tomorrow, you won‚Äôt know how to fix it.
* You rely on luck instead of logic.

üí° **Example:**

```java
if (someList.size() > 1) {
    process(someList.get(1));
}
```

It might ‚Äúwork,‚Äù but you don‚Äôt stop to ask:
‚Äî What if the list is empty?
‚Äî Why index 1, not 0?
‚Äî Could there be concurrency issues?

That‚Äôs *programming by coincidence.*

---

### üö¶ 4. **Be intentional and critical**

> ‚ÄúPragmatic Programmers think critically about all code, including our own.‚Äù

You don‚Äôt just accept code because it ‚Äúworks.‚Äù You ask:

* Is this the simplest solution?
* Is it maintainable?
* Is it testable?
* Is it clear to others?

That‚Äôs what it means to **code consciously**, not mechanically.

---

### üß† 5. **Testing, refactoring, and performance**

They mention other key ideas:

* **Algorithm Speed** ‚Üí Think about performance before it‚Äôs a problem.
* **Refactoring** ‚Üí Keep improving existing code.
* **Code That‚Äôs Easy to Test** ‚Üí Write code in a way that makes testing simple.
* **Evil Wizards** ‚Üí Be careful with auto-generated code (don‚Äôt trust magic tools unless you understand them).

---

### üöó 6. **Car-driving analogy**

> ‚ÄúGood, safe drivers are constantly reviewing the situation‚Ä¶‚Äù

Just like driving:

* Most of the time, you‚Äôre doing normal stuff (coding routines).
* But a good driver keeps an eye out for *potential dangers* ‚Äî traffic, pedestrians, sudden changes.
* Similarly, a good programmer keeps thinking, checking assumptions, and watching for problems.

So ‚Äî **don‚Äôt code on autopilot.**
Always stay aware, deliberate, and thoughtful.

---

### ‚úÖ **In summary**

| Wrong Mindset                               | Pragmatic Mindset                                      |
| ------------------------------------------- | ------------------------------------------------------ |
| ‚ÄúCoding is just typing what‚Äôs designed.‚Äù    | ‚ÄúCoding is continuous design and decision-making.‚Äù     |
| ‚ÄúIf it works, it‚Äôs fine.‚Äù                   | ‚ÄúIf it‚Äôs clear, maintainable, and correct, it‚Äôs fine.‚Äù |
| ‚ÄúI‚Äôll fix it later.‚Äù                        | ‚ÄúI understand *why* it works and how to improve it.‚Äù   |
| ‚ÄúThe tool generated it ‚Äî I don‚Äôt care how.‚Äù | ‚ÄúI must understand the code, even if it‚Äôs generated.‚Äù  |

---

Would you like me to show you a **Java example of ‚Äúprogramming by coincidence‚Äù vs. ‚Äúprogramming with intent‚Äù**?
It‚Äôll make this lesson super clear.


Perfect, buddy üëá let‚Äôs see what **‚ÄúProgramming by coincidence‚Äù vs ‚ÄúProgramming with intent‚Äù** looks like in real Java code.

---

## üß± Example Scenario

Let‚Äôs say you‚Äôre writing a small method to **calculate a user‚Äôs discount** based on how much they spent.

---

### ‚ùå **Programming by Coincidence**

```java
public double calculateDiscount(double total) {
    double discount = 0;
    
    if (total > 100) {
        discount = total * 0.1;  // 10% discount
    } else if (total > 50) {
        discount = 5; // fixed discount
    }
    
    return discount;
}
```

#### üö© What‚Äôs wrong here?

At first glance, it ‚Äúworks‚Äù‚Ä¶ but let‚Äôs think:

* What if `total` is negative? (bug)
* Why 5? Why 100? ‚Äî there‚Äôs no reasoning or documentation.
* What happens if the company changes discount rules?
* What if we later need to apply customer-level discounts (VIPs)?
* What if floating-point rounding matters?

üëâ This is **‚Äúprogramming by coincidence.‚Äù**
It works *by luck*, not by clear understanding or design.

---

### ‚úÖ **Programming with Intent**

Let‚Äôs write the same logic consciously, with reasoning and flexibility.

```java
public class DiscountPolicy {
    private static final double VIP_DISCOUNT_RATE = 0.15;
    private static final double STANDARD_DISCOUNT_RATE = 0.10;
    private static final double SMALL_DISCOUNT_AMOUNT = 5.0;
    
    public double calculateDiscount(double total, boolean isVip) {
        if (total < 0) {
            throw new IllegalArgumentException("Total cannot be negative");
        }

        if (isVip) {
            return total * VIP_DISCOUNT_RATE;
        }

        if (total > 100) {
            return total * STANDARD_DISCOUNT_RATE;
        }

        if (total > 50) {
            return SMALL_DISCOUNT_AMOUNT;
        }

        return 0;
    }
}
```

#### üí° Why is this ‚Äúintentional programming‚Äù?

* ‚úÖ Clear **constants** explain the logic (no ‚Äúmagic numbers‚Äù).
* ‚úÖ Edge cases are handled (negative total).
* ‚úÖ Easy to change discount rules ‚Äî no need to touch business logic.
* ‚úÖ Self-documenting: the method‚Äôs intent is obvious.
* ‚úÖ Easy to test ‚Äî deterministic output.

---

### üß† How a Pragmatic Programmer Thinks

While writing this, you‚Äôre asking:

* ‚ÄúWhat are the possible inputs?‚Äù
* ‚ÄúWill this logic still make sense in 6 months?‚Äù
* ‚ÄúHow can I make this readable to others?‚Äù
* ‚ÄúCan I test it easily?‚Äù
* ‚ÄúIf rules change, where will I update it?‚Äù

That mindset turns you from a **coder** into a **software craftsman.**

---

### üöÄ Quick Summary

| Concept     | By Coincidence            | With Intent                        |
| ----------- | ------------------------- | ---------------------------------- |
| Mindset     | ‚ÄúIt works, who cares why‚Äù | ‚ÄúI understand *why* it works‚Äù      |
| Flexibility | Hard-coded rules          | Configurable constants or metadata |
| Testing     | Hard to test              | Simple, predictable                |
| Maintenance | Fragile                   | Easy to adapt                      |
| Confidence  | Low                       | High                               |

---

Would you like me to extend this example to show how **business rules could be moved to metadata/config (JSON or YAML)** ‚Äî like the next section *‚ÄúPut Abstractions in Code, Details in Metadata‚Äù* talks about?
That would connect both ideas together perfectly.




TIP 44: Don‚Äôt Program by Coincidence

=====================================================



Excellent üëè ‚Äî this section, **‚ÄúHow to Program Deliberately,‚Äù** is one of the *core philosophies* of *The Pragmatic Programmer*.

Let‚Äôs break it down so you can **learn fast and deeply**, with simple explanations and real-world developer mindset üß†üëá

---

## üß© The Main Idea

**Don‚Äôt write code accidentally ‚Äî write it intentionally.**

That means:

> You always know *why* something works, *how* it works, and *what* might break it.

When you don‚Äôt ‚Äî you‚Äôre programming ‚Äúby coincidence.‚Äù

---

## ‚ö° Let‚Äôs Decode Each Rule Quickly

### 1. **Be aware of what you‚Äôre doing**

> Don‚Äôt drift into messy situations like a frog in warm water ‚Äî small bad habits will boil you slowly.

üß† Example:
You start hardcoding some values *‚Äújust for now‚Äù*, skip one small validation, don‚Äôt fix one warning‚Ä¶
‚Üí Over time, your project becomes a pile of problems.

‚úÖ Always ask yourself:

* Why am I writing this code?
* Does this line belong here?
* Is there a simpler or cleaner way?

---

### 2. **Don‚Äôt code blindfolded**

> Never use a tool, library, or API you don‚Äôt understand.

üß† Example:
You copy a StackOverflow answer using `@Transactional(propagation = REQUIRES_NEW)` but don‚Äôt know what it does.
It ‚Äúworks‚Äù‚Ä¶ until you break all your database consistency. üò¨

‚úÖ Learn first, *then* use.

---

### 3. **Proceed from a plan**

> Always have a small plan ‚Äî even if it‚Äôs just in your head.

üß† Example:
Before coding, know:

* What is the goal?
* What are the inputs and outputs?
* What‚Äôs the success condition?

‚úÖ Plan prevents chaos.

---

### 4. **Rely only on reliable things**

> Don‚Äôt build on top of guesses, coincidences, or lucky outcomes.

üß† Example:
Your code only works when you restart twice?
Or it ‚Äúsometimes‚Äù passes tests?
That‚Äôs not reliability ‚Äî that‚Äôs luck.

‚úÖ Fix root causes, don‚Äôt accept ‚Äúit just works somehow.‚Äù

---

### 5. **Document your assumptions**

> If your code assumes something, write it down.

üß† Example:
You think `user.getName()` is never null ‚Äî prove it:

```java
assert user.getName() != null : "User name should not be null";
```

‚úÖ These small checks save hours of debugging later.

---

### 6. **Test assumptions, not just code**

> Verify what you *believe* to be true.

üß† Example:
If you think your function always returns sorted data ‚Äî test it:

```java
List<Integer> result = service.getIds();
assertTrue(isSorted(result));
```

‚úÖ Assertions = live documentation + protection.

---

### 7. **Prioritize effort**

> Focus on important, hard things ‚Äî infrastructure, core logic.

üß† Example:
Don‚Äôt spend 5 hours making your loading spinner look pretty when your API isn‚Äôt stable yet.

‚úÖ Do the tough, critical things first.

---

### 8. **Don‚Äôt be a slave to history**

> Old code is not sacred. Refactor or replace when needed.

üß† Example:
‚ÄúThis function has always been here‚Äù is not a reason to keep it.
If it‚Äôs ugly, slow, or confusing ‚Üí fix it.

‚úÖ Code evolves, or it dies.

---

### 9. **When something works but you don‚Äôt know why...**

> Stop. Investigate.
> If you don‚Äôt understand *why* it works, it might break tomorrow.

üß† Example:
If removing a `Thread.sleep(1000)` breaks your code ‚Äî that‚Äôs a red flag. It‚Äôs hiding a timing problem.

‚úÖ Know the reason behind every behavior.

---

## üéØ In short

| Rule                        | Mindset                |
| --------------------------- | ---------------------- |
| Always aware                | Stay conscious         |
| Don‚Äôt code blindfolded      | Learn your tools       |
| Plan before code            | Structure your thought |
| Rely on reliable things     | Avoid luck             |
| Document assumptions        | Be explicit            |
| Test assumptions            | Verify beliefs         |
| Prioritize effort           | Focus on impact        |
| Don‚Äôt be a slave to history | Refactor freely        |
| Don‚Äôt trust coincidences    | Understand everything  |

---

### üß† One-Sentence Summary:

> **‚ÄúDeliberate programming‚Äù means: every line of your code exists for a clear, known reason ‚Äî never by chance.**

---

Would you like me to show how this looks in a **real code example** ‚Äî like the ‚Äúblindfolded vs deliberate‚Äù approach in a Spring Boot service method?
It‚Äôll help you *see* this philosophy in practice.

=========================================================================================================================================================


That‚Äôs a **classic excerpt** from *The Pragmatic Programmer* ‚Äî the ‚ÄúRefactoring‚Äù section. üå±

Let‚Äôs break it down together üëá

---

### üí° **Main Idea**

The authors (Andrew Hunt & David Thomas) argue that **software development is not like building construction** ‚Äî it‚Äôs more like **gardening**.
Software isn‚Äôt something you build once and forget about. It grows, changes, and needs **constant care and refactoring** to stay healthy.

---

### üèóÔ∏è **Why the ‚Äúconstruction‚Äù metaphor fails**

In traditional building construction:

1. Architects design everything up front (blueprints).
2. Builders just follow the plan step by step.
3. Once the building is complete, it rarely changes.

But in **software**, requirements evolve, technologies shift, and design decisions need to adapt.
Unlike a building, software doesn‚Äôt remain static ‚Äî it *lives* and *changes.*

---

### üåø **Why ‚Äúgardening‚Äù fits better**

A garden:

* Starts with a plan but grows unpredictably.
* Needs pruning, replanting, fertilizing, and weeding.
* Requires ongoing care and small adjustments over time.

Similarly, software:

* Needs **refactoring** (pruning and reorganizing code).
* May require removing ‚Äúweeds‚Äù (bad patterns, dead code).
* Grows organically as new features are added.
* Needs continuous attention to stay maintainable and elegant.

---

### üß© **What is Refactoring**

> **Refactoring** = the process of improving the design, structure, and readability of code *without changing its behavior.*

It means:

* Splitting large methods into smaller ones.
* Renaming confusing variables.
* Simplifying logic.
* Removing duplication.
* Reorganizing modules for clarity.

It‚Äôs *not rewriting the whole thing*, but carefully reshaping it so that the software remains healthy and adaptable.

---

### üß† **Pragmatic takeaway**

Refactoring isn‚Äôt failure ‚Äî it‚Äôs **a natural and necessary part of growth**.
Just as gardeners continuously shape their gardens, developers continuously shape their codebase.

> ‚ÄúCode needs to evolve; it‚Äôs not a static thing.‚Äù

---

Would you like me to give you a **short modern summary** of this idea (like a paragraph you could quote in an essay or interview)?

Excellent ‚Äî this is another *Pragmatic Programmer* gem, and it‚Äôs the perfect continuation of the previous passage. Let‚Äôs unpack it clearly üëá

---

## üí° **Main Idea**

Refactoring is **not optional** ‚Äî it‚Äôs **a responsibility**.
The authors warn that skipping refactoring because of ‚Äútime pressure‚Äù is a **false economy**.
If you delay cleaning up bad code now, you‚Äôll pay a much **higher price** later when the system becomes larger and harder to change.

---

## üß± **The Real-World Problem**

You tell your boss:

> ‚ÄúThe code works, but I need another week to refactor it.‚Äù

Their likely response:

> ‚ÄúWe don‚Äôt have time for that. Just ship it.‚Äù

That‚Äôs the **real-world tension**: developers understand the technical debt; managers focus on deadlines. But, as the authors point out, **ignoring refactoring under time pressure is shortsighted** ‚Äî you‚Äôre just pushing the pain into the future, when it‚Äôll be *more expensive* and *riskier* to fix.

---

## ü©∫ **The Medical Analogy**

Think of messy code as a **growth** in the body:

* If you remove it early, it‚Äôs minor surgery.
* If you ignore it, it grows and spreads ‚Äî and removing it later is *far more dangerous*.
* Wait too long, and the **entire system might die** (i.e., the codebase becomes unmaintainable).

It‚Äôs a vivid metaphor ‚Äî and it perfectly captures the idea of **technical debt compounding over time**.

---

## ‚öôÔ∏è **Tip 47 ‚Äî Refactor Early, Refactor Often**

This is the practical rule the authors give:

* üîÅ Don‚Äôt wait for a ‚Äúbig refactoring day.‚Äù
* üìù Keep a running list of parts that need refactoring.
* ‚è∞ Schedule them ‚Äî treat refactoring as real work, not a luxury.
* üì¢ Communicate ‚Äî let your team and users know what‚Äôs being refactored and when.

---

## üß† **Modern Summary**

Refactoring is preventive maintenance for your codebase.
If you postpone it to save time now, you‚Äôll pay for it with interest later ‚Äî in bugs, complexity, and frustration.
Refactor continuously, not just when things break.

> **Refactor early, refactor often ‚Äî or you‚Äôll eventually refactor in panic.**

---

Would you like me to summarize this *Real-World Complications* section in **one short paragraph** (e.g., something you could memorize or use in a talk/interview)?

========================================================================================================================================================================

Perfect ‚Äî you‚Äôve reached one of the most *practical* and *famous* sections of **The Pragmatic Programmer**: *How to Refactor*.
Let‚Äôs go through it step by step so you learn it fast and deeply üëá

---

## üß† What Refactoring Really Means

Refactoring = **redesigning code without changing what it does**.
It‚Äôs about **improving structure**, **removing duplication**, and **making code easier to maintain** ‚Äî *while keeping behavior the same*.

The authors remind you that refactoring started in the **Smalltalk** world (where tools and class browsers made it easy) ‚Äî and later became popular thanks to **Martin Fowler‚Äôs book *Refactoring* (1999)**.

But they also warn:

> Refactoring is not chaos. Don‚Äôt rip up code ‚Äúwith wild abandon.‚Äù
> Do it **slowly, deliberately, and carefully**.

---

## ‚öôÔ∏è Martin Fowler‚Äôs 3 Core Rules for Safe Refactoring

### 1Ô∏è‚É£ Don‚Äôt refactor *and* add features at the same time

When you refactor, focus only on improving structure ‚Äî no new functionality.
Mixing the two will confuse your goal and make debugging harder.

### 2Ô∏è‚É£ Have good tests ‚Äî and run them constantly

Before refactoring, you must have **reliable regression tests**.
Each time you change the code, **run the tests immediately**.
That way, if something breaks, you‚Äôll know exactly what caused it.

> üß© **Tests give you courage to refactor.** Without them, you‚Äôre walking blind.

### 3Ô∏è‚É£ Take small, deliberate steps

Don‚Äôt rewrite everything at once.
Instead, make *tiny* safe changes ‚Äî e.g.

* move one field between classes,
* merge two similar methods,
* rename a variable.

After *each* change ‚Üí run the tests.
This step-by-step approach avoids long debugging sessions.

---

## üß∞ Automatic Refactoring Tools (Then & Now)

At the time the book was written (1999), refactoring tools were only in **Smalltalk**.
Now, every modern IDE (IntelliJ, Eclipse, VS Code, etc.) has:

* Rename refactorings
* Extract method/class
* Move/inline methods
* Change signatures safely
  These are the ‚Äúrefactoring browsers‚Äù the authors predicted ‚Äî and they were right!

---

## üí£ Handling Big Changes

When you make **drastic refactors** (like changing a module‚Äôs interface):

* Intentionally **break the build** so that dependent code fails to compile.
* This forces you to find and update all the affected parts immediately.
  That‚Äôs how you avoid hidden mismatches between old and new code.

---

## üß© Final Message

> ‚ÄúIf it hurts now, but will hurt even more later ‚Äî fix it now.‚Äù
>
> Don‚Äôt live with broken windows. Clean as you go.
> Refactor both the problem and the code that depends on it.

---

## üß† Quick Summary to Memorize

> **Refactor deliberately:**
>
> * Don‚Äôt mix with new features
> * Have strong tests
> * Take small, safe steps
>
> **Refactor early, refactor often ‚Äî never live with broken windows.**

---

Would you like me to give you a **short practical guide** ‚Äî like a checklist you can use in your real coding workflow to know *when* and *how* to refactor safely (with examples)?

======================================================================================================================================================================



Excellent ‚Äî this section, **‚ÄúDigging for Requirements,‚Äù** is one of the most insightful parts of *The Pragmatic Programmer*. It teaches how to **separate true requirements** from **policies, assumptions, and implementation details**, and how to truly **understand users**.

Let‚Äôs unpack it step by step üëá

---

## üß± **1. What Is a True Requirement?**

The book starts by asking:

> ‚ÄúHow can you recognize a true requirement while you‚Äôre digging through all the surrounding dirt?‚Äù

### ‚úÖ A **requirement** is:

> Something that **must be accomplished** by the system.

Example of *clear requirements*:

* ‚ÄúAn employee record may be viewed only by a nominated group of people.‚Äù
* ‚ÄúThe cylinder-head temperature must not exceed the critical value.‚Äù
* ‚ÄúThe editor will highlight keywords depending on file type.‚Äù

üëâ These are **goals or conditions** that the system must satisfy ‚Äî not specific ways to achieve them.

---

## ‚öôÔ∏è **2. Why Requirements Are Hard**

Because **people don‚Äôt usually express real requirements clearly**.
They mix in:

* **Current business policies**
* **Implementation ideas**
* **Personal habits**

Let‚Äôs look at the example from the book:

### ‚ùå User says:

> ‚ÄúOnly an employee‚Äôs supervisors and the personnel department may view that employee‚Äôs records.‚Äù

### ‚úÖ Better requirement:

> ‚ÄúOnly authorized users may view an employee‚Äôs record.‚Äù

---

## üîç **3. Difference Between Requirement and Policy**

| Concept            | Meaning                    | Example                                     | Problem if Mixed Up       |
| ------------------ | -------------------------- | ------------------------------------------- | ------------------------- |
| **Requirement**    | What must happen           | ‚ÄúOnly authorized users may view records.‚Äù   | Flexible and future-proof |
| **Policy**         | How it happens *today*     | ‚ÄúOnly supervisors and HR can view records.‚Äù | Changes frequently        |
| **Implementation** | How the system enforces it | e.g., Access control code or metadata       | Should be adaptable       |

### üí° The Key Insight:

If you code the *policy* instead of the *requirement*, you‚Äôll have to **rewrite the program every time the policy changes**.
But if you design based on *requirement*, you can just **update configuration or metadata**.

---

## ü™û **4. User Interface Example**

### ‚ùå User says:

> ‚ÄúWe need a list box to select the loan term.‚Äù

This might sound like a requirement, but it‚Äôs often not.
Ask:

* Do they really *need* a **list box**?
* Or do they just need a **way to select** the loan term?

### ‚úÖ True requirement:

> ‚ÄúThe system must let the user choose a loan term.‚Äù

Now developers can decide *how* to implement that ‚Äî a list box, dropdown, voice input, etc.

---

## üí¨ **5. Find the Real Reason Behind User Actions**

> ‚ÄúIt‚Äôs important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it.‚Äù

Users often describe **their current process**, not **their real need**.
Your job is to find the **why** behind the **what**.

Example:

* User: ‚ÄúWe print reports every morning.‚Äù
* Real reason: ‚ÄúWe need to know daily inventory levels.‚Äù
  ‚Üí Maybe you can build a dashboard instead of a printed report.

‚úÖ **You‚Äôre solving business problems, not reproducing old habits.**

---

## üßç‚Äç‚ôÇÔ∏è **6. Become a User Yourself**

The authors give brilliant advice:

> ‚ÄúBecome a user.‚Äù

That means:

* If you‚Äôre building a system for customer support ‚Üí sit with the help desk.
* Building stock management ‚Üí work in the warehouse for a few days.

This helps you:

* Understand **real workflow**
* Build **trust** with users
* Gather **true insights** that users might never articulate

‚ö†Ô∏è Just don‚Äôt interfere ‚Äî observe and learn.

---

## üß† **7. Tip 52 ‚Äî Work with a User to Think Like a User**

> ‚ÄúThe requirements mining process is also the time to build a rapport with your user base.‚Äù

* You‚Äôre not just collecting requirements.
* You‚Äôre **building relationships and trust**.
* This makes users more honest, more open, and more cooperative later.

---

## üß© **8. Summary of Lessons**

| Lesson                                           | Meaning                                                               |
| ------------------------------------------------ | --------------------------------------------------------------------- |
| **True requirements ‚â† user statements**          | Dig deeper ‚Äî users often describe current practice, not actual needs. |
| **Separate requirement, policy, implementation** | Keeps your system flexible and maintainable.                          |
| **Don‚Äôt hardcode business rules**                | Put policies in metadata/configuration instead.                       |
| **Understand the ‚Äúwhy‚Äù behind requests**         | Solve business problems, not habits.                                  |
| **Work with users directly**                     | You‚Äôll build empathy, trust, and insight.                             |

---

## ‚ö° Example in Practice

Imagine you‚Äôre building an HR system.

### User says:

> ‚ÄúSupervisors and HR can see employee salaries.‚Äù

### If you code it directly:

```java
if(user.role.equals("SUPERVISOR") || user.role.equals("HR")) {
   showSalary();
}
```

When company policy changes (‚ÄúFinance can also see salaries‚Äù), you must **change the code**.

### But if you abstract it:

```java
if(user.isAuthorized("VIEW_SALARY")) {
   showSalary();
}
```

Now you just update **metadata or configuration**, not your code.

That‚Äôs **the power of separating requirement from policy**.

---

## üèÅ **Bottom Line**

> **Good developers don‚Äôt just listen ‚Äî they interpret.**

To ‚Äúdig for requirements‚Äù means:

* Don‚Äôt take user statements at face value.
* Find what *really needs to be achieved*.
* Design the system so that when policies change (and they will), your software doesn‚Äôt break.

---

Would you like me to show a **diagram that visually separates requirement ‚Üí policy ‚Üí implementation**?
It‚Äôs one of the best ways to understand this concept permanently.



