How Does Duplication Arise?
	1. Imposed duplication - Developers feel they have ne choice - the environment seems to require duplication

	2. Inadvertant duplication - Developers don't realize that they are duplicating information

	3. Impatient duplication - Developers get lazy and duplicate because it seems easier.

	4. Interdeveloper duplication - Multiple people on a team (or on different teams) duplicate a piece of information.


Eliminate Effects Between Unrelated Things.

* Orthogonality means components are independent

* Change one part doesn't require changes in another.

Orthogonality = "no overlap"
If two ideas, skills, or systems are orthogonal, they work separetely without stepping on each other.

So when someone says:
	Keep your system orthogonal
	They mean: "Design it so the parts are independent. Don't mix concerns."

You get two major benefits if you write orthogonal systems: increased productivity and reduced risk.

Grain Productivity
	1. Changes are localized, so development time and testing time are reduced. It's easier to write relatively small, self-contained components than a single large block of code. Simple components can be designed, coded, unit tested, and then forgotten - there is no need to keep changing existsing code as you add new code.

	2. An orthogonal approach also promotes reuse. If components have specific, well-defined responsibilities, they can be combined with new components in ways that were not envisioned by their original implementors. The more loosely coupled your systems the easier they are to reconfigure and reengineer.


Reduce Risk.
An orthogonal approach reduces the risks inherent in any development.
	
	1. Diseased sections of code are isolated. If a module is sick, it's less likely to spread the symptoms around the rest of the system. It's also easier to slice it out and transplant in something new and healthy.

	2. The resulting system is less fragile. Make small changes and fixes to a particular area, and any problems you generate will be restricted to that area.

	3. An orthogonal system will probably be better tested, because it will be easier to design and run tests on its components.

	4. You wil not be as tightly tied to a particular vendor, product or platform, because the interfaces to these third-party components will be isolated to smaller parts of the overall development. 

Coding
	There are several techniques you can use to maintain orthogonality

		1. Keep your code decoupled: Write shy code - modules that don't reveal anything unnecessary to other modules and that don't rely on other modules' implementations. Try the Law of Demeter which we discuss in Decoupling and the Law of Demeter. If you need to change an object's state, get the object to do it for you. This way your code remains isolated from the other code's implementation and increases the chances that you'll remain orthogonal.

		2. Avoid global data: Every time your code references global data, it ties itself into the other components that share that data. Even globals that you intend only to read can lead to trouble(for example, if you suddenly need to change your code to be multithreaded). In general, your code is easier to understand and maintain if you explicity pass any required context into your modules. In object-oriented applications, context is often passed as parameters to objects' constructors.

		3. Avoid similar functions: Often you'll come across a set of functions that all look similar - maybe they share common code at the start and end, but each has a different central algorithm. Duplicate code is a symptom of structural problems. have a look at STRATEGY PATTERN in Design Patterns for a better implementation. 



Tracer Bullets


The tracer code approach has many advantages:

	1. Users get to see something working early. - If you have successfully communicated what you are doing, your users will know they are seeing something immature. They won't be disappointed by a lack of functionality; they'll be estatic to see some visible progress toward their system. They also get to contribute as the project progresses, increasing their buy-in. These same users will likely be the people who'll tell you how close to target each iteration is.

	2. Developers build a structure to work in.  - The most daunting piece of paper is the one with nothing written on it. If you have worked out all the end-to-end interactions of your application, and have embodied them in code, then your team won't need to pull as much out of thin air. This makes everyone more productive, and encourages consistency.

	3. You have an integration platform - As the system is connected end-to-end, you have an environment to which you can add new pieces of code once they have been unit-tested. Rahter than attempting a big-bang integration, you'll be integrating every day(often many times a day). The impact of each new change is more apparent, and the interactions are more limited, so debugginh and testing are faster and more accurate.

	4. You have something to demonstrate. Project sponsors and top brass have a tendency to want to see demos at the most inconvenient times. With tracer code, you'll always have something to show them.

| Feature          | Tracer Code                                   | Prototype                           |
| ---------------- | --------------------------------------------- | ----------------------------------- |
| **Code Quality** | Production-quality, clean                     | Quick & dirty                       |
| **Purpose**      | Build structure for real system               | Explore idea / validate approach    |
| **Lifespan**     | Stays and grows into final product            | Often discarded                     |
| **Architecture** | Uses the **real architecture & tech**         | May skip architecture               |
| **Example**      | First working â€œlogin + DB + APIâ€ in a new app | Mocked-up UI for testing with users |



Things to Prototype
What sorts of things might you choose to investigate with a prototype? Anything that carries risk. Anything that hasn't been tried before, or that is absolutely critical to the final system. Anything unproven, experimental, or doubtful. Anything you aren't comfortable with. You can prototype.

	1. Architecture.
	2. New functionality in an existing system.
	3. Structure or contents of external data.
	4. Third-party tools or components.
	5. Performance issues.
	6. User interface design

NOTE: PROTOTYPE TO LEARN

How to Use Prototypes
When building a prototype, what details can you ignore?

	Correctness: You may be able to use dummy data where appropriate

	Completeness: The prototype may function only in a very limited sense, perhaps with only one preselected piece of input data and one menu item.

	Robustness: Error checking is likely to be incomplete or missing entirely. If you stray from predefined path, the prototype may crash and burn in a glorious display of pyrotechnics. That's okay.

How Not to Use Prototypes

	Before you embark on any code-base prototyping, make sure that everyone understands that you are writing disposable code. Prototypes can be deceptively attractive to people who don't know that they are just prototypes. You must make it very clear that this code disposable, incomplete, and unable to be completed.


================================================================

Estimating

	Core Idea
		* Estimating is not about 100% accurate.
		* It's about being close enough to guide decisions.
		* With practice, you'll develop an engineer's intuition for size, time, cost, and performance.

	That's why they say:
		Estimate to avoid surprises. 

ğŸ” Ballpark Estimation â€” Meaning

A ballpark estimate is a rough, approximate guess about cost, time, or effort.
	â€¢	Itâ€™s not exact.
	â€¢	Itâ€™s good enough to see the scale of the work.
	â€¢	The idea comes from baseball â†’ if the ball lands somewhere in the ballpark, itâ€™s close enough to count.

ğŸ‘‰ In software:
A ballpark estimate tells stakeholders if something is going to take days, weeks, or months â€” not the exact number of hours.


Where Do Estimates Come From?

	All estimates are based on models of the problem. But before we get too deeply into the techniques of building models, we have to mention a basic estimating trick that always gives good answers: ask someone who's already done it. Before you get too committed to model building, cast around for someone who's been in a similar situation in the past.

--

Estimating Project Schedules.
	This needn't be a paradox if you practice incremental development, repeating the following steps.
		1. Check requirements
		2. Analyze risk
		3. Design, implement, integrate.
		4. Validate with the users.


Tip 19: Iterate the Schedule with the Code.
	â€œIterate the schedule with the codeâ€ = make your timeline a living, accurate thing driven by real engineering signals and automation. It turns scheduling from guesswork into an ongoing, measurable process that adapts as your codebase (and uncovered realities) evolve.


What to Say When Asked for an Estimate.

You say, "I'll get back to you."

Example

ğŸ‘ At the coffee machine:
Manager: â€œHow long do you think adding that report feature will take?â€
Developer: â€œEh, maybe 2 days?â€
â†’ A week later: Manager says â€œYou said 2 days, why isnâ€™t it done yet?â€

ğŸ‘ Better:
Developer: â€œI canâ€™t really say without looking at the code. Iâ€™ll check and get back with a proper estimate.â€
â†’ Now the expectation is managed.



===============================================================================================================================



The Basic Tools.

    Tip 20: Keep knowledge in Plain Text.

    Examples
        âœ… Good (Plain Text)

        Source code (.java, .py, .c)

        Configuration files (.properties, .yml, .json, .ini)

        Documentation (.md, .txt, .rst)

        SQL scripts (.sql)

        Infrastructure as code (.tf, .yaml for Kubernetes)

        âŒ Bad (Opaque/Binary)

        Word docs (.docx) for specs (hard to diff/merge)

        Excel sheets (.xls) for configuration (not transparent, easy to break)

        Proprietary binary formats for data dumps (canâ€™t grep/diff)

        Closed tools where knowledge lives only in a GUI (no text to store in Git)


The Power of Test
    Since larger and slower aren't the most frequently requested features from users, why bother with plain text? Whar are the benefits?

    1. Insurance against absolescence.
    2. Leverage.
    3. Easier testing.


Shell Games
	* If you do all work using GUIs, you are missing out on the full capabilities of your environment. You won't be able to automate common tasks, or use the full power of the tools avaulable to you. And you won't be able to combine your tools to create customized macro tools. A benefit of GUIs is WYSIWYG - what you see is what you get. The disadvantages is WYSIAYG - what you see is all you get.

TIP 21
	Use the Power of Command Shells.



Debugging Strategies
	NOTE:
		Bug Reproduction
			No, our bugs aren't really multiplying (although some of them are probably old enough to do it legally). We're talking about a different kind of reproduction.
			The best way to start fixing a bug is to make it reproducible. After all, if you can't reproduce it, how will you know if it is ever fixed?
			But we want more than a bug that can be reproduced by following some long series of steps; we want a bug that can be reproduced with a single command. It's a lot harder to fuix a bug if you have to go through 15 steps to get to the point where the bug shows up.

=========================================================================================================================================================

PRAGMATIC PARANOIA.
 Tip 30 - You can't write PERFECT SOFTWARE.

If there's any doubt, we validate all information we're given. We use assertions to detect bad data. We check for consistency, put constraints on database columns, and generally feel pretty good about ourselves. 
	BUT PRAGMATIC PROGRAMMERS TAKE THIS A STEP FURTHER. THEY DON'T TRUST THEMSELVES, EITHER. Knowing that no one writes PERFECT CODE, including themselves, Pragmatic Programmers code in defenses against their own mistakes. We describe the first defensive measure in Design by Contract: clients and suppliers must agree on rights and responsibilities.

1.	Notes - Dead Programs Tell No Lies.
		* Principle: Fail fast - stop program when error occur instead of continuing in an invalid state.
		* Reason: A crash is visible and contained; silent bugs cause data corruption, security risks, hidden failures.
		* Practices: 
			* Validate inputs & invariants.
			* Throw exception on unexpected conditions. 
			* Log errors clearly before termination
			* Use rollback/recovery mechanisms (e.g DB transactions)

		* Mindset: Better no result than a wrong result.

2. Assertive Programming - describes an easy method of checking along the way - write code that actively verifies your assumptions.
	Assertive Programming = don't just assume your code is correct - make your codde check its own assumpltions as it runs.
	For example: 
		* If you assume a list is never empty -> assert it
	This way, if reality doesn't match your assumptions, the program fails immediately instead of quietly producing wrong result.


	Notes for your Notebook
		* Assertive Programming = check assumptions explicity with assertions.
		* Purpose: catch bugs early, fail fast, self-documented expectations.
		* Use for: preconditions, postconditions, invariants
		* Don't assume -> assert!

----------------------------------------------------------------------------------------------------------------------

When everybody actually is out to get you, paranoia is just good thinking
														-> Woody Allen

What does it mean? 
If danger is real, caution isn't paranoia - it's smart thinking.
	We have learned:
		1. Don't trust your code, your assumptions, or even your own inputs.
		2. If bugs, bad data, and user mistakes will happen, then being "paranoid" - adding checks, assertions, and defensive code - isn't crazy. IT'S JUST GOOD ENGINEERING.

===============================================================================================================================================================

																					DESIGN BY CONTRACT
													Nothing astonishes men so much as common sense and plain dealing. - Ralph Waldo Emerson

One of the best solutions for ensuring plain dealing is the CONTRACT - A Contract defines your rights and responsibilities, as well as those of the other party. 

DbC is commong sense formalized:
	* DbC is common sense formalized:
		* Caller promises preconditions (e.g amount > 0).
		* Method promises postconditions (e.g balance increases).
		* System enforces invariants (e.g total debits == total credits).
	* This "plain dealing" is just being explicit about what's expected and what's guaranteed.
	* Instead of "trust me, it works," DbC is like a contract you can't ignore.

Example:
	Without contract
```
public void withdraw(Account account, double amount) {
    // assumes account is valid, amount positive, and enough balance...
    account.setBalance(account.getBalance() - amount);
}
```

With Design by Contract 

```
public void withdraw(Account account, double amount) {
    assert account != null : "Account must not be null";
    assert amount > 0 : "Amount must be positive";
    assert account.getBalance() >= amount : "Insufficient funds";

    double oldBalance = account.getBalance();
    account.setBalance(oldBalance - amount);

    assert account.getBalance() == oldBalance - amount : "Postcondition failed";
}
```

================================================================================================

			Loop Invariants

A loop invariant is a logical statement that is always true:
	* Before the loop starts.
	* During every iteration of the loop.
	* When the loop ends.

It's like a mini contract for your loop - describing what must always hold ture, even while the loop is in progress.

Example: Finding the Maximum in an Array.

```
int m = arr[0];      // assume arr.length > 0
int i = 1;

// Loop invariant: m = max(arr[0 : i-1])
while (i < arr.length) {
    m = Math.max(m, arr[i]);
    i = i + 1;
}
```

1. Before loop starts:
	* m = arr[0];
	* i = 1
	* INVARIANT says: "m" is the max of all elements from arr[0] up to i.
	* So m = max(arr[0:0]) => TRUE

------------------------------------------------------------------------------------------------

												SEMANTIC INVARIANTS
1. They Are fundamental truths about a system - rules that must never be broken unders any circumstances.
2. They act like PHILOSOPHICAL CONTRACTS: higher-level guarantees that guide design decisions.
3. They differ from business policies (which can change), because semantic invariants are permanent and central to the meaning of the system.

Example: Debit Card Transaction System.
	1. Requirement: A user must never be charged twice for the same transaction.
	2. Why? Because duplicate charges would break trust and create financial harm.
	3. So, the system is designed with this invariant in mind

Difference Between Policy and Semantic Invariant
1. Policy: Rules that can change(ATM withdrawals are limited to 500 dollar in a day - management can update this.
2. Semantic Invariant: Rules that must always hold.


Tip 35: Finish What You Start.
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
																	BEND, OR BREAK
In Reversibility, we talked about the perils of irreversible decisions. In this chapter, we'll tell you how to make reversible decisions. In this chapter, we'll tell tou how to make reversible decisions, so your code can stay flexible and adaptable in the face of an uncertain world.

First we need to look at coupling - the dependencies among modules of code. In decoupling and the Law of Demeter we'll show how to keep separate concepts separate, and decrease coupling.

A key concept in creating flexible code is the separation of a data model from a view, or presentation, of that model. We'll decouple models fron views in It's Just A View.

Finally, thereâ€™s a technique for decoupling modules even further by providing a meeting place where modules can exchange data anonymously and asynchronously. This is the topic of Blackboards.
Armed with these techniques, you can write code that will â€œroll with the punches.â€


```
The Law of Demeter, also known as the principle of least knowledge, is a software design guideline that states an object should only communicate with its immediate "friends" and not with "strangers". This means an object should only call methods on itself, objects passed in as arguments, any objects it creates, or its direct component objects. The core idea is to reduce coupling between classes, making code easier to test, refactor, and maintain. 
```

--------------------------------------------------------------------------------------------------------------------------------------------

																			Decoupling and the Law of Demeter.
Good fences make good neighbors.

In Orthogonality, page 34, and Design By Contract, page 109, we suggested that writting "shy" code is beneficial. But "shy" works two ways: 
	1. Don't reveal yourself to others
	2. Don't interact with too many people.

-----

The Law Of Demeter for Functions

The Law of Demeter for functions attempts to minimize coupling between modules in any given program. It tries to prevent you from reaching into an object to gain access to a third objecct's methods.
By writing "shy" code that honors the Law Of Demeter as much as possible, we can achieve our objective:
	
	Tip 36: Minimize Coupling Between Modules

====================================================================================================================
																Metadata-Driven Applications
Put Abstractions in Code, Details in Metadata.

There are several benefits to this approach:
	1. It forces you to decouple your design, which results in a more flexible and adaptable program.
	2. It forces you to create a more robust, abstract design be deferring details - deferring them all the way out of the program.
	3. You can customize the application without recompiling it. You can also use this level of customization to provide easy work-arounds for critical bugs in live production systems.
	4. You may even be able to implement several differen projects using the same application engine, but with different metadata.


DON'T WRITE DODO-CODE
Without metadata, your code is not as adaptable or flexible as it could be. Is this a bad thing? Well, out here in the real world, species that don't adapt die. 

The dodo didn't adapt to the presence of humans and their livestock on the island of Mauritius, and quickly became extinct. It was the first documented extinction of a species at the hand of man.
DON'T LET YOUR PROJECT (OR YOUR CAREER) GO THE WAY OF THE DODO.



============================================================================================================================================

---

### ğŸ§© 1. **What people *think* coding is**

The book says:

> â€œConventional wisdom says that once a project is in the coding phase, the work is mostly mechanicalâ€¦â€

That means many people (especially managers or beginners) **believe coding is just typing** â€” taking a design document and translating it into code like a robot.
They think once design is done, programmers just follow instructions.

ğŸ’¬ Example of that mindset:

> â€œWe already designed it. Just go code it up!â€
> (as if the programmerâ€™s job is mechanical work, not thinking work)

---

### âš ï¸ 2. **But in reality â€” coding requires constant thinking**

The authors argue:

> â€œCoding is not mechanical.â€

Every line of code involves **choices**:

* Which data structure is best?
* Is this logic clean and readable?
* What happens if the input is invalid?
* Is this algorithm efficient?
* What if I need to change this later?

So, a good programmer is always **analyzing, questioning, and improving** â€” not just typing.

---

### ğŸ’¥ 3. **â€œProgramming by coincidenceâ€**

They warn:

> â€œDevelopers who donâ€™t actively think about their code are programming by coincidence.â€

That means:

* You write code that â€œjust happensâ€ to work â€” but you donâ€™t really understand *why*.
* If it breaks tomorrow, you wonâ€™t know how to fix it.
* You rely on luck instead of logic.

ğŸ’¡ **Example:**

```java
if (someList.size() > 1) {
    process(someList.get(1));
}
```

It might â€œwork,â€ but you donâ€™t stop to ask:
â€” What if the list is empty?
â€” Why index 1, not 0?
â€” Could there be concurrency issues?

Thatâ€™s *programming by coincidence.*

---

### ğŸš¦ 4. **Be intentional and critical**

> â€œPragmatic Programmers think critically about all code, including our own.â€

You donâ€™t just accept code because it â€œworks.â€ You ask:

* Is this the simplest solution?
* Is it maintainable?
* Is it testable?
* Is it clear to others?

Thatâ€™s what it means to **code consciously**, not mechanically.

---

### ğŸ§  5. **Testing, refactoring, and performance**

They mention other key ideas:

* **Algorithm Speed** â†’ Think about performance before itâ€™s a problem.
* **Refactoring** â†’ Keep improving existing code.
* **Code Thatâ€™s Easy to Test** â†’ Write code in a way that makes testing simple.
* **Evil Wizards** â†’ Be careful with auto-generated code (donâ€™t trust magic tools unless you understand them).

---

### ğŸš— 6. **Car-driving analogy**

> â€œGood, safe drivers are constantly reviewing the situationâ€¦â€

Just like driving:

* Most of the time, youâ€™re doing normal stuff (coding routines).
* But a good driver keeps an eye out for *potential dangers* â€” traffic, pedestrians, sudden changes.
* Similarly, a good programmer keeps thinking, checking assumptions, and watching for problems.

So â€” **donâ€™t code on autopilot.**
Always stay aware, deliberate, and thoughtful.

---

### âœ… **In summary**

| Wrong Mindset                               | Pragmatic Mindset                                      |
| ------------------------------------------- | ------------------------------------------------------ |
| â€œCoding is just typing whatâ€™s designed.â€    | â€œCoding is continuous design and decision-making.â€     |
| â€œIf it works, itâ€™s fine.â€                   | â€œIf itâ€™s clear, maintainable, and correct, itâ€™s fine.â€ |
| â€œIâ€™ll fix it later.â€                        | â€œI understand *why* it works and how to improve it.â€   |
| â€œThe tool generated it â€” I donâ€™t care how.â€ | â€œI must understand the code, even if itâ€™s generated.â€  |

---

Would you like me to show you a **Java example of â€œprogramming by coincidenceâ€ vs. â€œprogramming with intentâ€**?
Itâ€™ll make this lesson super clear.


Perfect, buddy ğŸ‘‡ letâ€™s see what **â€œProgramming by coincidenceâ€ vs â€œProgramming with intentâ€** looks like in real Java code.

---

## ğŸ§± Example Scenario

Letâ€™s say youâ€™re writing a small method to **calculate a userâ€™s discount** based on how much they spent.

---

### âŒ **Programming by Coincidence**

```java
public double calculateDiscount(double total) {
    double discount = 0;
    
    if (total > 100) {
        discount = total * 0.1;  // 10% discount
    } else if (total > 50) {
        discount = 5; // fixed discount
    }
    
    return discount;
}
```

#### ğŸš© Whatâ€™s wrong here?

At first glance, it â€œworksâ€â€¦ but letâ€™s think:

* What if `total` is negative? (bug)
* Why 5? Why 100? â€” thereâ€™s no reasoning or documentation.
* What happens if the company changes discount rules?
* What if we later need to apply customer-level discounts (VIPs)?
* What if floating-point rounding matters?

ğŸ‘‰ This is **â€œprogramming by coincidence.â€**
It works *by luck*, not by clear understanding or design.

---

### âœ… **Programming with Intent**

Letâ€™s write the same logic consciously, with reasoning and flexibility.

```java
public class DiscountPolicy {
    private static final double VIP_DISCOUNT_RATE = 0.15;
    private static final double STANDARD_DISCOUNT_RATE = 0.10;
    private static final double SMALL_DISCOUNT_AMOUNT = 5.0;
    
    public double calculateDiscount(double total, boolean isVip) {
        if (total < 0) {
            throw new IllegalArgumentException("Total cannot be negative");
        }

        if (isVip) {
            return total * VIP_DISCOUNT_RATE;
        }

        if (total > 100) {
            return total * STANDARD_DISCOUNT_RATE;
        }

        if (total > 50) {
            return SMALL_DISCOUNT_AMOUNT;
        }

        return 0;
    }
}
```

#### ğŸ’¡ Why is this â€œintentional programmingâ€?

* âœ… Clear **constants** explain the logic (no â€œmagic numbersâ€).
* âœ… Edge cases are handled (negative total).
* âœ… Easy to change discount rules â€” no need to touch business logic.
* âœ… Self-documenting: the methodâ€™s intent is obvious.
* âœ… Easy to test â€” deterministic output.

---

### ğŸ§  How a Pragmatic Programmer Thinks

While writing this, youâ€™re asking:

* â€œWhat are the possible inputs?â€
* â€œWill this logic still make sense in 6 months?â€
* â€œHow can I make this readable to others?â€
* â€œCan I test it easily?â€
* â€œIf rules change, where will I update it?â€

That mindset turns you from a **coder** into a **software craftsman.**

---

### ğŸš€ Quick Summary

| Concept     | By Coincidence            | With Intent                        |
| ----------- | ------------------------- | ---------------------------------- |
| Mindset     | â€œIt works, who cares whyâ€ | â€œI understand *why* it worksâ€      |
| Flexibility | Hard-coded rules          | Configurable constants or metadata |
| Testing     | Hard to test              | Simple, predictable                |
| Maintenance | Fragile                   | Easy to adapt                      |
| Confidence  | Low                       | High                               |

---

Would you like me to extend this example to show how **business rules could be moved to metadata/config (JSON or YAML)** â€” like the next section *â€œPut Abstractions in Code, Details in Metadataâ€* talks about?
That would connect both ideas together perfectly.




TIP 44: Donâ€™t Program by Coincidence

=====================================================



Excellent ğŸ‘ â€” this section, **â€œHow to Program Deliberately,â€** is one of the *core philosophies* of *The Pragmatic Programmer*.

Letâ€™s break it down so you can **learn fast and deeply**, with simple explanations and real-world developer mindset ğŸ§ ğŸ‘‡

---

## ğŸ§© The Main Idea

**Donâ€™t write code accidentally â€” write it intentionally.**

That means:

> You always know *why* something works, *how* it works, and *what* might break it.

When you donâ€™t â€” youâ€™re programming â€œby coincidence.â€

---

## âš¡ Letâ€™s Decode Each Rule Quickly

### 1. **Be aware of what youâ€™re doing**

> Donâ€™t drift into messy situations like a frog in warm water â€” small bad habits will boil you slowly.

ğŸ§  Example:
You start hardcoding some values *â€œjust for nowâ€*, skip one small validation, donâ€™t fix one warningâ€¦
â†’ Over time, your project becomes a pile of problems.

âœ… Always ask yourself:

* Why am I writing this code?
* Does this line belong here?
* Is there a simpler or cleaner way?

---

### 2. **Donâ€™t code blindfolded**

> Never use a tool, library, or API you donâ€™t understand.

ğŸ§  Example:
You copy a StackOverflow answer using `@Transactional(propagation = REQUIRES_NEW)` but donâ€™t know what it does.
It â€œworksâ€â€¦ until you break all your database consistency. ğŸ˜¬

âœ… Learn first, *then* use.

---

### 3. **Proceed from a plan**

> Always have a small plan â€” even if itâ€™s just in your head.

ğŸ§  Example:
Before coding, know:

* What is the goal?
* What are the inputs and outputs?
* Whatâ€™s the success condition?

âœ… Plan prevents chaos.

---

### 4. **Rely only on reliable things**

> Donâ€™t build on top of guesses, coincidences, or lucky outcomes.

ğŸ§  Example:
Your code only works when you restart twice?
Or it â€œsometimesâ€ passes tests?
Thatâ€™s not reliability â€” thatâ€™s luck.

âœ… Fix root causes, donâ€™t accept â€œit just works somehow.â€

---

### 5. **Document your assumptions**

> If your code assumes something, write it down.

ğŸ§  Example:
You think `user.getName()` is never null â€” prove it:

```java
assert user.getName() != null : "User name should not be null";
```

âœ… These small checks save hours of debugging later.

---

### 6. **Test assumptions, not just code**

> Verify what you *believe* to be true.

ğŸ§  Example:
If you think your function always returns sorted data â€” test it:

```java
List<Integer> result = service.getIds();
assertTrue(isSorted(result));
```

âœ… Assertions = live documentation + protection.

---

### 7. **Prioritize effort**

> Focus on important, hard things â€” infrastructure, core logic.

ğŸ§  Example:
Donâ€™t spend 5 hours making your loading spinner look pretty when your API isnâ€™t stable yet.

âœ… Do the tough, critical things first.

---

### 8. **Donâ€™t be a slave to history**

> Old code is not sacred. Refactor or replace when needed.

ğŸ§  Example:
â€œThis function has always been hereâ€ is not a reason to keep it.
If itâ€™s ugly, slow, or confusing â†’ fix it.

âœ… Code evolves, or it dies.

---

### 9. **When something works but you donâ€™t know why...**

> Stop. Investigate.
> If you donâ€™t understand *why* it works, it might break tomorrow.

ğŸ§  Example:
If removing a `Thread.sleep(1000)` breaks your code â€” thatâ€™s a red flag. Itâ€™s hiding a timing problem.

âœ… Know the reason behind every behavior.

---

## ğŸ¯ In short

| Rule                        | Mindset                |
| --------------------------- | ---------------------- |
| Always aware                | Stay conscious         |
| Donâ€™t code blindfolded      | Learn your tools       |
| Plan before code            | Structure your thought |
| Rely on reliable things     | Avoid luck             |
| Document assumptions        | Be explicit            |
| Test assumptions            | Verify beliefs         |
| Prioritize effort           | Focus on impact        |
| Donâ€™t be a slave to history | Refactor freely        |
| Donâ€™t trust coincidences    | Understand everything  |

---

### ğŸ§  One-Sentence Summary:

> **â€œDeliberate programmingâ€ means: every line of your code exists for a clear, known reason â€” never by chance.**

---

Would you like me to show how this looks in a **real code example** â€” like the â€œblindfolded vs deliberateâ€ approach in a Spring Boot service method?
Itâ€™ll help you *see* this philosophy in practice.

=========================================================================================================================================================


Thatâ€™s a **classic excerpt** from *The Pragmatic Programmer* â€” the â€œRefactoringâ€ section. ğŸŒ±

Letâ€™s break it down together ğŸ‘‡

---

### ğŸ’¡ **Main Idea**

The authors (Andrew Hunt & David Thomas) argue that **software development is not like building construction** â€” itâ€™s more like **gardening**.
Software isnâ€™t something you build once and forget about. It grows, changes, and needs **constant care and refactoring** to stay healthy.

---

### ğŸ—ï¸ **Why the â€œconstructionâ€ metaphor fails**

In traditional building construction:

1. Architects design everything up front (blueprints).
2. Builders just follow the plan step by step.
3. Once the building is complete, it rarely changes.

But in **software**, requirements evolve, technologies shift, and design decisions need to adapt.
Unlike a building, software doesnâ€™t remain static â€” it *lives* and *changes.*

---

### ğŸŒ¿ **Why â€œgardeningâ€ fits better**

A garden:

* Starts with a plan but grows unpredictably.
* Needs pruning, replanting, fertilizing, and weeding.
* Requires ongoing care and small adjustments over time.

Similarly, software:

* Needs **refactoring** (pruning and reorganizing code).
* May require removing â€œweedsâ€ (bad patterns, dead code).
* Grows organically as new features are added.
* Needs continuous attention to stay maintainable and elegant.

---

### ğŸ§© **What is Refactoring**

> **Refactoring** = the process of improving the design, structure, and readability of code *without changing its behavior.*

It means:

* Splitting large methods into smaller ones.
* Renaming confusing variables.
* Simplifying logic.
* Removing duplication.
* Reorganizing modules for clarity.

Itâ€™s *not rewriting the whole thing*, but carefully reshaping it so that the software remains healthy and adaptable.

---

### ğŸ§  **Pragmatic takeaway**

Refactoring isnâ€™t failure â€” itâ€™s **a natural and necessary part of growth**.
Just as gardeners continuously shape their gardens, developers continuously shape their codebase.

> â€œCode needs to evolve; itâ€™s not a static thing.â€

---

Would you like me to give you a **short modern summary** of this idea (like a paragraph you could quote in an essay or interview)?

Excellent â€” this is another *Pragmatic Programmer* gem, and itâ€™s the perfect continuation of the previous passage. Letâ€™s unpack it clearly ğŸ‘‡

---

## ğŸ’¡ **Main Idea**

Refactoring is **not optional** â€” itâ€™s **a responsibility**.
The authors warn that skipping refactoring because of â€œtime pressureâ€ is a **false economy**.
If you delay cleaning up bad code now, youâ€™ll pay a much **higher price** later when the system becomes larger and harder to change.

---

## ğŸ§± **The Real-World Problem**

You tell your boss:

> â€œThe code works, but I need another week to refactor it.â€

Their likely response:

> â€œWe donâ€™t have time for that. Just ship it.â€

Thatâ€™s the **real-world tension**: developers understand the technical debt; managers focus on deadlines. But, as the authors point out, **ignoring refactoring under time pressure is shortsighted** â€” youâ€™re just pushing the pain into the future, when itâ€™ll be *more expensive* and *riskier* to fix.

---

## ğŸ©º **The Medical Analogy**

Think of messy code as a **growth** in the body:

* If you remove it early, itâ€™s minor surgery.
* If you ignore it, it grows and spreads â€” and removing it later is *far more dangerous*.
* Wait too long, and the **entire system might die** (i.e., the codebase becomes unmaintainable).

Itâ€™s a vivid metaphor â€” and it perfectly captures the idea of **technical debt compounding over time**.

---

## âš™ï¸ **Tip 47 â€” Refactor Early, Refactor Often**

This is the practical rule the authors give:

* ğŸ” Donâ€™t wait for a â€œbig refactoring day.â€
* ğŸ“ Keep a running list of parts that need refactoring.
* â° Schedule them â€” treat refactoring as real work, not a luxury.
* ğŸ“¢ Communicate â€” let your team and users know whatâ€™s being refactored and when.

---

## ğŸ§  **Modern Summary**

Refactoring is preventive maintenance for your codebase.
If you postpone it to save time now, youâ€™ll pay for it with interest later â€” in bugs, complexity, and frustration.
Refactor continuously, not just when things break.

> **Refactor early, refactor often â€” or youâ€™ll eventually refactor in panic.**

---

Would you like me to summarize this *Real-World Complications* section in **one short paragraph** (e.g., something you could memorize or use in a talk/interview)?

========================================================================================================================================================================

Perfect â€” youâ€™ve reached one of the most *practical* and *famous* sections of **The Pragmatic Programmer**: *How to Refactor*.
Letâ€™s go through it step by step so you learn it fast and deeply ğŸ‘‡

---

## ğŸ§  What Refactoring Really Means

Refactoring = **redesigning code without changing what it does**.
Itâ€™s about **improving structure**, **removing duplication**, and **making code easier to maintain** â€” *while keeping behavior the same*.

The authors remind you that refactoring started in the **Smalltalk** world (where tools and class browsers made it easy) â€” and later became popular thanks to **Martin Fowlerâ€™s book *Refactoring* (1999)**.

But they also warn:

> Refactoring is not chaos. Donâ€™t rip up code â€œwith wild abandon.â€
> Do it **slowly, deliberately, and carefully**.

---

## âš™ï¸ Martin Fowlerâ€™s 3 Core Rules for Safe Refactoring

### 1ï¸âƒ£ Donâ€™t refactor *and* add features at the same time

When you refactor, focus only on improving structure â€” no new functionality.
Mixing the two will confuse your goal and make debugging harder.

### 2ï¸âƒ£ Have good tests â€” and run them constantly

Before refactoring, you must have **reliable regression tests**.
Each time you change the code, **run the tests immediately**.
That way, if something breaks, youâ€™ll know exactly what caused it.

> ğŸ§© **Tests give you courage to refactor.** Without them, youâ€™re walking blind.

### 3ï¸âƒ£ Take small, deliberate steps

Donâ€™t rewrite everything at once.
Instead, make *tiny* safe changes â€” e.g.

* move one field between classes,
* merge two similar methods,
* rename a variable.

After *each* change â†’ run the tests.
This step-by-step approach avoids long debugging sessions.

---

## ğŸ§° Automatic Refactoring Tools (Then & Now)

At the time the book was written (1999), refactoring tools were only in **Smalltalk**.
Now, every modern IDE (IntelliJ, Eclipse, VS Code, etc.) has:

* Rename refactorings
* Extract method/class
* Move/inline methods
* Change signatures safely
  These are the â€œrefactoring browsersâ€ the authors predicted â€” and they were right!

---

## ğŸ’£ Handling Big Changes

When you make **drastic refactors** (like changing a moduleâ€™s interface):

* Intentionally **break the build** so that dependent code fails to compile.
* This forces you to find and update all the affected parts immediately.
  Thatâ€™s how you avoid hidden mismatches between old and new code.

---

## ğŸ§© Final Message

> â€œIf it hurts now, but will hurt even more later â€” fix it now.â€
>
> Donâ€™t live with broken windows. Clean as you go.
> Refactor both the problem and the code that depends on it.

---

## ğŸ§  Quick Summary to Memorize

> **Refactor deliberately:**
>
> * Donâ€™t mix with new features
> * Have strong tests
> * Take small, safe steps
>
> **Refactor early, refactor often â€” never live with broken windows.**

---

Would you like me to give you a **short practical guide** â€” like a checklist you can use in your real coding workflow to know *when* and *how* to refactor safely (with examples)?

======================================================================================================================================================================



Excellent â€” this section, **â€œDigging for Requirements,â€** is one of the most insightful parts of *The Pragmatic Programmer*. It teaches how to **separate true requirements** from **policies, assumptions, and implementation details**, and how to truly **understand users**.

Letâ€™s unpack it step by step ğŸ‘‡

---

## ğŸ§± **1. What Is a True Requirement?**

The book starts by asking:

> â€œHow can you recognize a true requirement while youâ€™re digging through all the surrounding dirt?â€

### âœ… A **requirement** is:

> Something that **must be accomplished** by the system.

Example of *clear requirements*:

* â€œAn employee record may be viewed only by a nominated group of people.â€
* â€œThe cylinder-head temperature must not exceed the critical value.â€
* â€œThe editor will highlight keywords depending on file type.â€

ğŸ‘‰ These are **goals or conditions** that the system must satisfy â€” not specific ways to achieve them.

---

## âš™ï¸ **2. Why Requirements Are Hard**

Because **people donâ€™t usually express real requirements clearly**.
They mix in:

* **Current business policies**
* **Implementation ideas**
* **Personal habits**

Letâ€™s look at the example from the book:

### âŒ User says:

> â€œOnly an employeeâ€™s supervisors and the personnel department may view that employeeâ€™s records.â€

### âœ… Better requirement:

> â€œOnly authorized users may view an employeeâ€™s record.â€

---

## ğŸ” **3. Difference Between Requirement and Policy**

| Concept            | Meaning                    | Example                                     | Problem if Mixed Up       |
| ------------------ | -------------------------- | ------------------------------------------- | ------------------------- |
| **Requirement**    | What must happen           | â€œOnly authorized users may view records.â€   | Flexible and future-proof |
| **Policy**         | How it happens *today*     | â€œOnly supervisors and HR can view records.â€ | Changes frequently        |
| **Implementation** | How the system enforces it | e.g., Access control code or metadata       | Should be adaptable       |

### ğŸ’¡ The Key Insight:

If you code the *policy* instead of the *requirement*, youâ€™ll have to **rewrite the program every time the policy changes**.
But if you design based on *requirement*, you can just **update configuration or metadata**.

---

## ğŸª **4. User Interface Example**

### âŒ User says:

> â€œWe need a list box to select the loan term.â€

This might sound like a requirement, but itâ€™s often not.
Ask:

* Do they really *need* a **list box**?
* Or do they just need a **way to select** the loan term?

### âœ… True requirement:

> â€œThe system must let the user choose a loan term.â€

Now developers can decide *how* to implement that â€” a list box, dropdown, voice input, etc.

---

## ğŸ’¬ **5. Find the Real Reason Behind User Actions**

> â€œItâ€™s important to discover the underlying reason why users do a particular thing, rather than just the way they currently do it.â€

Users often describe **their current process**, not **their real need**.
Your job is to find the **why** behind the **what**.

Example:

* User: â€œWe print reports every morning.â€
* Real reason: â€œWe need to know daily inventory levels.â€
  â†’ Maybe you can build a dashboard instead of a printed report.

âœ… **Youâ€™re solving business problems, not reproducing old habits.**

---

## ğŸ§â€â™‚ï¸ **6. Become a User Yourself**

The authors give brilliant advice:

> â€œBecome a user.â€

That means:

* If youâ€™re building a system for customer support â†’ sit with the help desk.
* Building stock management â†’ work in the warehouse for a few days.

This helps you:

* Understand **real workflow**
* Build **trust** with users
* Gather **true insights** that users might never articulate

âš ï¸ Just donâ€™t interfere â€” observe and learn.

---

## ğŸ§  **7. Tip 52 â€” Work with a User to Think Like a User**

> â€œThe requirements mining process is also the time to build a rapport with your user base.â€

* Youâ€™re not just collecting requirements.
* Youâ€™re **building relationships and trust**.
* This makes users more honest, more open, and more cooperative later.

---

## ğŸ§© **8. Summary of Lessons**

| Lesson                                           | Meaning                                                               |
| ------------------------------------------------ | --------------------------------------------------------------------- |
| **True requirements â‰  user statements**          | Dig deeper â€” users often describe current practice, not actual needs. |
| **Separate requirement, policy, implementation** | Keeps your system flexible and maintainable.                          |
| **Donâ€™t hardcode business rules**                | Put policies in metadata/configuration instead.                       |
| **Understand the â€œwhyâ€ behind requests**         | Solve business problems, not habits.                                  |
| **Work with users directly**                     | Youâ€™ll build empathy, trust, and insight.                             |

---

## âš¡ Example in Practice

Imagine youâ€™re building an HR system.

### User says:

> â€œSupervisors and HR can see employee salaries.â€

### If you code it directly:

```java
if(user.role.equals("SUPERVISOR") || user.role.equals("HR")) {
   showSalary();
}
```

When company policy changes (â€œFinance can also see salariesâ€), you must **change the code**.

### But if you abstract it:

```java
if(user.isAuthorized("VIEW_SALARY")) {
   showSalary();
}
```

Now you just update **metadata or configuration**, not your code.

Thatâ€™s **the power of separating requirement from policy**.

---

## ğŸ **Bottom Line**

> **Good developers donâ€™t just listen â€” they interpret.**

To â€œdig for requirementsâ€ means:

* Donâ€™t take user statements at face value.
* Find what *really needs to be achieved*.
* Design the system so that when policies change (and they will), your software doesnâ€™t break.

---

Would you like me to show a **diagram that visually separates requirement â†’ policy â†’ implementation**?
Itâ€™s one of the best ways to understand this concept permanently.



